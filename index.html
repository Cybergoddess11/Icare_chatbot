import React, { useState, useEffect, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, collection, query, getDocs } from 'firebase/firestore';

// --- Firebase Configuration (Explicitly set for GitHub Pages deployment) ---
// This configuration is for your Firebase project 'icare-mental-wellness-bot'.
// You MUST fill in the placeholders below for your specific Firebase Web App.
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
  // ACTION REQUIRED: Replace "YOUR_FIREBASE_WEB_APP_API_KEY_HERE" with your Firebase Web App's API Key.
  // Find this in your Firebase Project Settings -> 'Your apps' section -> Web App config.
  apiKey: "AIzaSyDTlZaAtFFS85oKA3RGBdnOrWradgPXs", // Your Firebase Web App API Key from console
  authDomain: "icare-mental-wellness-bot.firebaseapp.com",
  projectId: "icare-mental-wellness-bot", // Your Firebase Project ID
  storageBucket: "icare-mental-wellness-bot.appspot.com",
  // ACTION REQUIRED: Replace "YOUR_MESSAGING_SENDER_ID_HERE" with your Firebase Web App's Messaging Sender ID.
  // Find this in your Firebase Project Settings -> 'Your apps' section -> Web App config.
  messagingSenderId: "1087754401209", // Your Firebase Messaging Sender ID from console
  // ACTION REQUIRED: Replace "YOUR_FIREBASE_WEB_APP_ID_HERE" with your Firebase Web App's App ID.
  // Find this in your Firebase Project Settings -> 'Your apps' section -> Web App config.
  appId: "1:1087754401209:web:93ee57afb07d496036f268" // Your Firebase Web App App ID from console
};

// The appId variable used for Firestore path is your Firebase Project ID
const appIdForFirestorePath = "icare-mental-wellness-bot"; // Your Firebase Project ID

// The initialAuthToken is for Canvas environment, will be null on GitHub Pages
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Initialize Firebase outside the component to avoid re-initialization
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

// --- Main App Component ---
function App() {
    const [messages, setMessages] = useState([]);
    const [userInput, setUserInput] = useState('');
    const [isLoading, setIsLoading] = useState(true); // Initial loading for auth & KB
    const [isSending, setIsSending] = useState(false); // For when an AI response is being generated
    const [authStatus, setAuthStatus] = useState('Connecting...');
    const [userId, setUserId] = useState('anonymous');
    const [knowledgeBaseData, setKnowledgeBaseData] = useState({});

    const chatMessagesRef = useRef(null); // Ref for scrolling chat

    // Gemini API Key - THIS IS YOUR KEY for the Gemini AI model (pre-filled)
    const GEMINI_API_KEY = "AIzaSyCW0ZP6a7s4vMV_9WXMU29nTFHuqLBGSYE"; 
    const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;

    // --- Firebase Authentication and Knowledge Base Loading ---
    useEffect(() => {
        // Initial bot greeting
        setMessages([
            { sender: 'bot', text: "Hello! I'm Icare. I'm here to listen if you need to talk, or just want a little encouragement. How are you feeling today?" }
        ]);

        const unsubscribe = onAuthStateChanged(auth, async (user) => {
            let currentUserId = 'anonymous';
            if (user) {
                currentUserId = user.uid;
                setAuthStatus(`User ID: ${currentUserId.substring(0, 8)}...`);
                console.log("User authenticated:", currentUserId);
            } else {
                setAuthStatus('Connecting...');
                try {
                    if (initialAuthToken) { // This will be null on GitHub Pages
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                    currentUserId = auth.currentUser?.uid || crypto.randomUUID();
                    setAuthStatus(`User ID: ${currentUserId.substring(0, 8)}...`);
                    console.log("Anonymous user connected:", currentUserId);
                } catch (error) {
                    console.error("Firebase Auth error:", error);
                    setAuthStatus(`Connection failed: ${error.message}`); // Display the specific error message
                    setMessages(prev => [...prev, { sender: 'bot', text: `I'm having trouble connecting right now. Some features may be limited. Error: ${error.message}` }]);
                    setIsLoading(false); // Stop loading, but disable interactions
                    return;
                }
            }
            setUserId(currentUserId);
            await loadKnowledgeBaseFromFirestore(currentUserId);
            setIsLoading(false); // All initial loading done
        });

        return () => unsubscribe(); // Cleanup auth listener
    }, []); // Run once on component mount

    // Scroll to bottom whenever messages change
    useEffect(() => {
        if (chatMessagesRef.current) {
            chatMessagesRef.current.scrollTop = chatMessagesRef.current.scrollHeight;
        }
    }, [messages]);

    const loadKnowledgeBaseFromFirestore = async (currentUserId) => {
        setMessages(prev => [...prev, { sender: 'bot', text: 'Preparing my knowledge base...' }]);
        let loadedKb = {};
        try {
            // Use appIdForFirestorePath (your Firebase Project ID) here
            const knowledgeBaseRef = collection(db, `artifacts/${appIdForFirestorePath}/users/${currentUserId}/knowledgeBase`);
            const q = query(knowledgeBaseRef);
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                console.log("No custom knowledge base found for this user.");
                setMessages(prev => [...prev, { sender: 'bot', text: "My custom knowledge base is empty. If you'd like me to learn specific answers, add them to my data!" }]);
            } else {
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    if (data.question && data.answer) {
                        loadedKb[data.question.toLowerCase().trim()] = data.answer;
                    }
                });
                console.log(`Custom knowledge base loaded with ${Object.keys(loadedKb).length} entries.`);
                setKnowledgeBaseData(loadedKb);
            }
        } catch (error) {
            console.error("Error loading custom knowledge base from Firestore:", error);
            setMessages(prev => [...prev, { sender: 'bot', text: `I'm having trouble accessing my custom knowledge. I'll rely on my general understanding for now.` }]);
        } finally {
            // Remove the "Preparing my knowledge base..." message if it's the last one
            setMessages(prev => {
                const lastMessage = prev[prev.length - 1];
                if (lastMessage && lastMessage.sender === 'bot' && lastMessage.text.includes('Preparing my knowledge base...')) {
                    return prev.slice(0, prev.length - 1); // Remove it
                }
                return prev;
            });
        }
    };

    // --- Chatbot Logic (modified for Conversation Memory) ---
    const getBotResponse = async (userMessage, promptType = 'chat') => {
        setIsSending(true); // Disable input and buttons
        setMessages(prev => [...prev, { sender: 'bot', text: 'Thinking...' }]); // Show thinking message

        let geminiPrompt;
        let responseText = null;

        // Construct chat history for Gemini to maintain context
        // Only send the last few messages to keep the payload manageable
        const conversationHistory = messages.slice(-5).map(msg => ({ // Last 5 messages
            role: msg.sender === 'user' ? 'user' : 'model',
            parts: [{ text: msg.text }]
        }));

        if (promptType === 'affirmation') {
            geminiPrompt = "Generate a short, positive, and encouraging affirmation for mental well-being, suitable for a student. Keep it concise.";
        } else if (promptType === 'reflection') {
            geminiPrompt = "Provide a thoughtful and gentle journaling or self-reflection prompt for a student to consider their feelings or experiences. Make it open-ended and supportive.";
        } else { // 'chat' type - check Firestore first
            const lowerCaseMessage = userMessage.toLowerCase().trim();

            if (knowledgeBaseData[lowerCaseMessage]) {
                responseText = knowledgeBaseData[lowerCaseMessage];
            } else {
                geminiPrompt = userMessage; // Fallback to Gemini for general chat
            }
        }

        // If response found in Firestore, use it immediately
        if (responseText) {
            setMessages(prev => prev.slice(0, prev.length - 1)); // Remove 'Thinking...'
            setIsSending(false);
            return responseText;
        }

        // Otherwise, call Gemini API
        try {
            const payload = {
                contents: [...conversationHistory, { role: 'user', parts: [{ text: geminiPrompt }] }]
            };

            let retries = 0;
            const maxRetries = 5;
            let delay = 1000;

            while (retries < maxRetries) {
                try {
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 429) {
                            retries++;
                            await new Promise(res => setTimeout(res, delay));
                            delay *= 2;
                            continue;
                        } else {
                            throw new Error(`API error: ${response.statusText}`);
                        }
                    }

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        return result.candidates[0].content.parts[0].text;
                    } else {
                        return "I'm having a little trouble understanding. Could you please rephrase or tell me more?";
                    }
                } catch (error) {
                    console.error("Fetch error:", error);
                    if (retries < maxRetries - 1) {
                        retries++;
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                    } else {
                        return "Oops! It seems I'm having trouble connecting to Gemini right now. Please try again in a bit.";
                    }
                }
            }
            return "I'm currently unable to connect to my knowledge source. Please try again later.";
        } catch (error) {
            console.error("Error communicating with Gemini API:", error);
            return "I'm having trouble connecting right now. Please try again in a moment.";
        } finally {
            setMessages(prev => prev.slice(0, prev.length - 1)); // Remove 'Thinking...' regardless of outcome
            setIsSending(false); // Re-enable input and buttons
        }
    };

    const handleSendMessage = async (messageText, type = 'chat') => {
        if (!messageText.trim() && type === 'chat') return;
        if (isLoading || isSending) return; // Prevent sending if still loading or sending

        setMessages(prev => [...prev, { sender: 'user', text: messageText }]);
        setUserInput(''); // Clear input after sending

        const botResponse = await getBotResponse(messageText, type);
        setMessages(prev => [...prev, { sender: 'bot', text: botResponse }]);
    };

    const handleKeyPress = (e) => {
        if (e.key === 'Enter' && userInput.trim() !== '') {
            handleSendMessage(userInput);
        }
    };

    return (
        <div className="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-gray-900"> {/* Page background */}
            <div className="chat-container w-full max-w-md bg-white dark:bg-gray-800 rounded-xl shadow-lg flex flex-col overflow-hidden">
                {/* Chat Header */}
                <div className="chat-header bg-black text-white p-4 text-center text-2xl font-bold rounded-t-xl">
                    Icare - Your Mental Wellness Companion
                </div>

                {/* Chat Messages Area */}
                <div id="chat-messages" ref={chatMessagesRef} className="flex-1 p-4 overflow-y-auto bg-gray-50 dark:bg-gray-700">
                    {messages.map((msg, index) => (
                        <div key={index} className={`flex mb-3 ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
                            <div className={`max-w-[75%] px-4 py-2 rounded-2xl text-base leading-snug ${
                                msg.sender === 'user'
                                    ? 'bg-yellow-400 text-black rounded-br-sm' // User message: vibrant yellow, black text
                                    : 'bg-yellow-100 text-black rounded-bl-sm' // Bot message: lighter yellow, black text
                            }`}>
                                {msg.text}
                            </div>
                        </div>
                    ))}
                </div>

                {/* Chat Input Area */}
                <div className="p-4 bg-gray-100 dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 flex flex-wrap gap-2 rounded-b-xl">
                    <input
                        type="text"
                        id="user-input"
                        className="flex-grow p-3 rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-black dark:text-white focus:outline-none focus:border-black focus:ring-2 focus:ring-black transition-all"
                        placeholder="Share what's on your mind..."
                        value={userInput}
                        onChange={(e) => setUserInput(e.target.value)}
                        onKeyPress={handleKeyPress}
                        disabled={isLoading || isSending}
                    />
                    <button
                        id="send-button"
                        className="px-6 py-3 bg-black text-white rounded-full font-semibold hover:bg-gray-800 transition-colors flex-shrink-0"
                        onClick={() => handleSendMessage(userInput)}
                        disabled={isLoading || isSending || !userInput.trim()}
                    >
                        Send
                    </button>
                    <button
                        id="affirmation-button"
                        className="px-6 py-3 bg-black text-white rounded-full font-semibold hover:bg-gray-800 transition-colors flex-shrink-0"
                        onClick={() => handleSendMessage('✨ Get Affirmation', 'affirmation')}
                        disabled={isLoading || isSending}
                    >
                        ✨ Get Affirmation
                    </button>
                    <button
                        id="reflection-button"
                        className="px-6 py-3 bg-black text-white rounded-full font-semibold hover:bg-gray-800 transition-colors flex-shrink-0"
                        onClick={() => handleSendMessage('✨ Reflection Prompt', 'reflection')}
                        disabled={isLoading || isSending}
                    >
                        ✨ Reflection Prompt
                    </button>
                    <div id="auth-status" className="w-full text-center text-xs text-gray-500 dark:text-gray-400 mt-2">
                        {authStatus}
                    </div>
                </div>
            </div>
        </div>
    );
}

export default App;
